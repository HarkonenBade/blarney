{-|
Module      : Blarney.Verilog
Description : Verilog generation
Copyright   : (c) Matthew Naylor, 2019
License     : MIT
Maintainer  : mattfn@gmail.com
Stability   : experimental

Convert Blarney functions to Verilog modules.
-}

module Blarney.Verilog
  ( writeVerilogModule  -- Generate Verilog module
  , writeVerilogTop     -- Generate Verilog top-level module
  ) where

-- Standard imports
import Prelude hiding ((<>))
import Data.List
import Numeric (showHex)
import System.IO
import Data.Maybe
import System.Process

-- Blarney imports
import Blarney.BV
import Blarney.Module
import Blarney.Interface
import Blarney.IfThenElse

-- Toplevel API
--------------------------------------------------------------------------------

-- | Convert given Blarney function to a Verilog module
writeVerilogModule :: Modular a
                   => a          -- ^ Blarney function
                   -> String     -- ^ Module name
                   -> String     -- ^ Output directory
                   -> IO ()
writeVerilogModule top mod dir =
    do system ("mkdir -p " ++ dir)
       nl <- netlist (makeModule top)
       writeVerilog fileName mod nl
  where
    fileName = dir ++ "/" ++ mod ++ ".v"

-- | Convert given Blarney function to a top-level Verilog module
writeVerilogTop :: Module ()  -- ^ Blarney module
                -> String     -- ^ Top-level module name
                -> String     -- ^ Output directory
                -> IO ()
writeVerilogTop top mod dir =
    do nl <- netlist top
       system ("mkdir -p " ++ dir)
       writeVerilog (dir ++ "/" ++ mod ++ ".v") mod nl
       writeFile (dir ++ "/" ++ mod ++ ".cpp") simCode
       writeFile (dir ++ "/" ++ mod ++ ".mk") makefileIncCode
       writeFile (dir ++ "/Makefile") makefileCode
  where
    fileName = dir ++ "/" ++ mod ++ ".v"

    simCode =
      unlines [
        "// Generated by Blarney"
      , "#include <verilated.h>"
      , "#include \"V" ++ mod ++ ".h\""
      , "V" ++ mod ++ " *top;"
      , "vluint64_t main_time = 0;"
      , "// Called by $time in Verilog"
      , "double sc_time_stamp () {"
      , "  return main_time;"
      , "}"
      , "int main(int argc, char** argv) {"
      , "  Verilated::commandArgs(argc, argv);"
      , "  top = new V" ++ mod ++ ";"
      , "  while (!Verilated::gotFinish()) {"
      , "    top->clock = 0; top->eval();"
      , "    top->clock = 1; top->eval();"
      , "    main_time++;"
      , "  }"
      , "  top->final(); delete top; return 0;"
      , "}"
      ]

    makefileIncCode =
      unlines [
        "all: " ++ mod
      , mod ++ ": *.v *.cpp"
      , "\tverilator -cc " ++ mod ++ ".v " ++ "-exe "
                           ++ mod ++ ".cpp " ++ "-o " ++ mod
                           ++ " -Wno-UNSIGNED "
                           ++ " -y $(BLARNEY_ROOT)/Verilog "
      , "\tmake -C obj_dir -j -f V" ++ mod ++ ".mk " ++ mod
      , "\tcp obj_dir/" ++ mod ++ " ."
      , "\trm -rf obj_dir"
      , ".PHONY: clean clean-" ++ mod
      , "clean: clean-" ++ mod
      , "clean-" ++ mod ++ ":"
      , "\trm -f " ++ mod
      ]

    makefileCode = "include *.mk"

writeVerilog :: String -> String -> [Net] -> IO ()
writeVerilog fileName modName netlist = do
  h <- openFile fileName WriteMode
  hPutStr h (showVerilogModule modName netlist $ "")
  hClose h

-- Internal helpers
--------------------------------------------------------------------------------

-- NetVerilog helper type
data NetVerilog = NetVerilog { decl :: Maybe ShowS -- declaration
                             , inst :: Maybe ShowS -- instanciation
                             , alws :: Maybe ShowS -- always block
                             }
-- pretty helpers
--------------------------------------------------------------------------------
chr = showChar
str = showString
x <> y      = x . y
x <+> y     = x <> space <> y
x <^> y     = x <> chr '\n' <> y
sep         = foldr (\x y -> x <+> y) (str "")
--vsep        = foldr (\x y -> x <^> y) (str "")
argStyle as = foldr (.) (str "") (intersperse (comma <> space) as)
brackets  s = chr '[' <> s <> chr ']'
parens    s = chr '(' <> s <> chr ')'
braces    s = chr '{' <> s <> chr '}'
dquotes   s = chr '"' <> s <> chr '"'
space       = chr ' '
dot         = chr '.'
comma       = chr ','
colon       = chr ':'
semi        = chr ';'
equals      = chr '='
-- general helpers
--------------------------------------------------------------------------------
showName :: (Int, Int) -> ShowS
showName (id, nOut) = chr 'v' <> shows id <> chr '_' <> shows nOut
showNameWidth :: Int -> (Int, Int) -> ShowS
showNameWidth width w = brackets (shows (width-1) <> str ":0") <+> showName w
showVerilogModule :: String -> [Net] -> ShowS
showVerilogModule modName netlst =
     str "module" <+> str modName <+> parens showIOs <> chr ';'
  <^> str "  " <> showComment "Declarations"
  <^> str "  " <> showCommentLine
  <>  foldl (\x y -> x <^> str "  " <> y) (str "") (catMaybes $ map decl netVs)
  <^> str "  " <> showComment "Instances"
  <^> str "  " <> showCommentLine
  <>  foldl (\x y -> x <^> str "  " <> y) (str "") (catMaybes $ map inst netVs)
  <^> str "  " <> showComment "Always block"
  <^> str "  " <> showCommentLine
  <^> str "  " <> str "always" <+> chr '@' <> parens (str "posedge clock") <+> str "begin"
  <> foldl (\x y -> x <^> str "    " <> y) (str "") (catMaybes $ map alws netVs)
  <^> str "  " <> str "end"
  <^> str "endmodule"
  where netVs = map genNetVerilog netlst
        netPrims = map netPrim netlst
        ins = [Input w s | (w, s) <- nub [(w, s) | Input w s <- netPrims]]
        outs = [Output w s | Output w s <- netPrims]
        showIOs = argStyle $ (str "input wire clock") : (map showIO (ins ++ outs))
        showIO (Input w s) = str "input wire" <+> brackets (shows (w-1) <> str ":0") <+> str s
        showIO (Output w s) = str "output wire" <+> brackets (shows (w-1) <> str ":0") <+> str s
        showIO _ = str ""
        showComment cmt = str "//" <+> str cmt
        --showCommentLine = remainCols (\r -> p "//" <> p (replicate (r-2) '/'))
        showCommentLine = str (replicate (78) '/')

-- declaration helpers
--------------------------------------------------------------------------------
declName width name =
  showNameWidth width name <> semi
declNameInitHex width wire init =
  showNameWidth width wire <+> equals <+> shows width <> str "'h" <> str (showHex init "") <> semi
declWireInitBits width wire b =
  str "wire" <+> showNameWidth width wire <+> equals <+> shows width <> str "'b" <> str bitStr <> semi
  where bitStr = replicate width $ bitChar b
        bitChar One = '1'
        bitChar Zero = '0'
        bitChar DontCare = 'x'
declWire width wire = str "wire" <+> declName width wire
declWireInit width wire init = str "wire" <+> declNameInitHex width wire init
declReg width reg = str "reg" <+> declName width reg
declRegInit width reg init = str "reg" <+> declNameInitHex width reg init
declRAM initFile numPorts _ dw id =
  --vsep $ map (\n -> declWire dw (id, n)) [0..numPorts-1]
  foldl (<+>) (str "") $ map (\n -> declWire dw (id, n)) [0..numPorts-1]
declRegFile initFile aw dw id =
      str "reg" <+> brackets (shows (dw-1) <> str ":0")
  <+> str "rf" <> shows id <+> brackets (parens (str "2**" <> shows aw) <> str "-1" <> str ":0") <> semi
  <> showInit
  where showInit = case initFile of
          ""    ->     str ""
          fname ->     str "\ngenerate initial $readmemh" <> parens
                       (str fname <> comma <+> str "rf" <> shows id) <> semi
                   <+> str "endgenerate"

-- instanciation helpers
--------------------------------------------------------------------------------
instPrefixOp op net =
      str "assign" <+> showName (netInstId net, 0) <+> equals
  <+> str op <> parens (showName (netInputs net !! 0)) <> semi
instInfixOp op net =
      str "assign" <+> showName (netInstId net, 0) <+> equals
  <+> showName (netInputs net !! 0)
  <+> str op <+> showName (netInputs net !! 1) <> semi
instShift w op net =
      str "assign" <+> showName (netInstId net, 0) <+> equals
  <+> a0 <+> str op <+> showName (netInputs net !! 1) <> semi
  where a0 = if op == ">>>" then str "$signed" <> parens a0name
                            else a0name
        a0name = showName (netInputs net !! 0)
instReplicate w net =
      str "assign" <+> showName (netInstId net, 0) <+> equals
  <+> braces (shows w <> braces (showName (netInputs net !! 0))) <> semi
instMux net =
      str "assign" <+> showName (netInstId net, 0) <+> equals
  <+> showName (netInputs net !! 0) <+> chr '?'
  <+> showName (netInputs net !! 1) <+> colon
  <+> showName (netInputs net !! 2) <> semi
instConcat net =
      str "assign" <+> showName (netInstId net, 0) <+> equals
  <+> braces ( showName (netInputs net !! 0) <> comma <+>
               showName (netInputs net !! 1)) <> semi
instSelectBits net hi lo =
      str "assign" <+> showName (netInstId net, 0) <+> equals
  <+> showName (netInputs net !! 0) <> brackets
      (shows hi <> colon <> shows lo) <> semi
instZeroExtend net wi wo =
      str "assign" <+> showName (netInstId net, 0) <+> equals
  <+> braces (braces (shows (wo-wi) <> braces (str "1'b0"))
  <>  comma <+> showName (netInputs net !! 0)) <> semi
instSignExtend net wi wo =
      str "assign" <+> showName (netInstId net, 0) <+> equals
  <+> braces (braces (shows (wo-wi) <> braces (showName (netInputs net !! 0)
  <>  brackets (shows (wi-1)))) <> comma
  <+> showName (netInputs net !! 0)) <> semi
instCustom net name ins outs params =
      str name <> showParams <> str name <> chr '_' <> shows (netInstId net) <+> showArgs
  <>  semi
  where numParams = length params
        showParams = if numParams == 0 then space
                     else chr '#' <> parens (argStyle allParams) <> space
        allParams = [ dot <> str key <> parens (str val) | (key :-> val, i) <- zip params [1..] ]
        args = zip ins (netInputs net) ++ [ (o, (netInstId net, n))
                                          | (o, n) <- zip (map fst outs) [0..] ]
        numArgs  = length args
        showArgs = parens (argStyle $ (str ".clock(clock)"):allArgs)
        allArgs  = [ dot <> str name <> parens (showName wire)
                   | ((name, wire), i) <- zip args [1..] ]
instTestPlusArgs net s =
      str "assign" <+> showName (netInstId net, 0) <+> equals
  <+> str "$test$plusargs" <> parens (dquotes $ str s) <+> str "== 0 ? 0 : 1;"
instOutput net s =
  str "assign" <+> str s <+> equals <+> showName (netInputs net !! 0) <> semi
instInput net s =
  str "assign" <+> showName (netInstId net, 0) <+> equals <+> str s <> semi
instRAM net i aw dw =
      str "BlockRAM#" <> parens (argStyle
                        [ str ".INIT_FILE"  <> parens (str (show $ fromMaybe "UNUSED" i))
                        , str ".ADDR_WIDTH" <> parens (shows aw)
                        , str ".DATA_WIDTH" <> parens (shows dw) ])
  <+> str "ram" <>  shows (netInstId net) <> parens (argStyle
                        [ str ".CLK(clock)"
                        , str ".DI"   <> parens (showName (netInputs net !! 1))
                        , str ".ADDR" <> parens (showName (netInputs net !! 0))
                        , str ".WE"   <> parens (showName (netInputs net !! 2))
                        , str ".DO"   <> parens (showName (netInstId net, 0)) ])
  <>  semi
instTrueDualRAM net i aw dw =
      str "BlockRAMTrueDual#" <> parens (argStyle
                        [ str ".INIT_FILE"  <> parens (str (show $ fromMaybe "UNUSED" i))
                        , str ".ADDR_WIDTH" <> parens (shows aw)
                        , str ".DATA_WIDTH" <> parens (shows dw) ])
  <+> str "ram" <> shows (netInstId net) <> parens (argStyle
                        [ str ".CLK(clock)"
                        , str ".DI_A"   <> parens (showName (netInputs net !! 1))
                        , str ".ADDR_A" <> parens (showName (netInputs net !! 0))
                        , str ".WE_A"   <> parens (showName (netInputs net !! 2))
                        , str ".DO_A"   <> parens (showName (netInstId net, 0))
                        , str ".DI_B"   <> parens (showName (netInputs net !! 4))
                        , str ".ADDR_B" <> parens (showName (netInputs net !! 3))
                        , str ".WE_B"   <> parens (showName (netInputs net !! 5))
                        , str ".DO_B"   <> parens (showName (netInstId net, 1)) ])
  <>  semi
instRegFileRead id net =
      str "assign" <+> showName (netInstId net, 0) <+> equals
  <+> str "rf" <> shows id <> brackets (showName (netInputs net !! 0)) <> semi

-- always block helpers
--------------------------------------------------------------------------------
alwsRegister net = showName (netInstId net, 0) <+> str "<="
               <+> showName (netInputs net !! 0) <> semi
alwsRegisterEn net =
      str "if" <+> parens (showName (netInputs net !! 0) <+> str "== 1")
  <+> showName (netInstId net, 0) <+> str "<=" <+> showName (netInputs net !! 1)
  <>  semi
alwsDisplay args net =
      str "if" <+> parens (showName (netInputs net !! 0) <+> str "== 1")
  <+> str "$write"
  <>  parens (argStyle $ fmtArgs args (tail (netInputs net)))
  <>  semi
  where fmtArgs [] _ = []
        fmtArgs (DisplayArgString s : args) wires = shows s : (fmtArgs args wires)
        fmtArgs (DisplayArgBit w : args) (wire:wires) = (showName wire) : (fmtArgs args wires)
alwsFinish net =
  str "if" <+> parens (showName (netInputs net !! 0) <+> str "== 1")
           <+> str "$finish" <> semi
alwsRegFileWrite id net =
      str "if" <+> parens (showName (netInputs net !! 0) <+> str "== 1")
  <+> str "rf" <> shows id <> brackets (showName (netInputs net !! 1))
  <+> str "<=" <+> showName (netInputs net !! 2) <> semi

-- generate NetVerilog
--------------------------------------------------------------------------------
genNetVerilog :: Net -> NetVerilog
genNetVerilog net = case netPrim net of
  Const w i             -> dfltNV { decl = Just $ declWireInit w nId i }
  ConstBits w b         -> dfltNV { decl = Just $ declWireInitBits w nId b }
  Add w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "+" net }
  Sub w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "-" net }
  Mul w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "*" net }
  Div w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "/" net }
  Mod w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "%" net }
  Not w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instPrefixOp "~" net }
  And w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "&" net }
  Or w                  -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "|" net }
  Xor w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "^" net }
  ShiftLeft w           -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instShift w "<<" net }
  ShiftRight w          -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instShift w ">>" net }
  ArithShiftRight w     -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instShift w ">>>" net }
  Equal w               -> dfltNV { decl = Just $ declWire 1 nId
                                  , inst = Just $ instInfixOp "==" net }
  NotEqual w            -> dfltNV { decl = Just $ declWire 1 nId
                                  , inst = Just $ instInfixOp "!=" net }
  LessThan w            -> dfltNV { decl = Just $ declWire 1 nId
                                  , inst = Just $ instInfixOp "<" net }
  LessThanEq w          -> dfltNV { decl = Just $ declWire 1 nId
                                  , inst = Just $ instInfixOp "<=" net }
  Register i w          -> dfltNV { decl = Just $ declRegInit w nId i
                                  , alws = Just $ alwsRegister net }
  RegisterEn i w        -> dfltNV { decl = Just $ declRegInit w nId i
                                  , alws = Just $ alwsRegisterEn net }
  BRAM i aw dw          -> dfltNV { decl = Just $ declRAM i 1 aw dw (netInstId net)
                                  , inst = Just $ instRAM net i aw dw }
  TrueDualBRAM i aw dw  -> dfltNV { decl = Just $ declRAM i 2 aw dw (netInstId net)
                                  , inst = Just $ instTrueDualRAM net i aw dw }
  ReplicateBit w        -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instReplicate w net }
  ZeroExtend wi wo      -> dfltNV { decl = Just $ declWire wo nId
                                  , inst = Just $ instZeroExtend net wi wo }
  SignExtend wi wo      -> dfltNV { decl = Just $ declWire wo nId
                                  , inst = Just $ instSignExtend net wi wo }
  SelectBits w hi lo    -> dfltNV { decl = Just $ declWire (1+hi-lo) nId
                                  , inst = Just $ instSelectBits net hi lo }
  Concat aw bw          -> dfltNV { decl = Just $ declWire (aw+bw) nId
                                  , inst = Just $ instConcat net }
  Mux w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instMux net }
  CountOnes w           -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instPrefixOp "$countones" net }
  Identity w            -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instPrefixOp "" net }
  Display args          -> dfltNV { alws = Just $ alwsDisplay args net }
  Finish                -> dfltNV { alws = Just $ alwsFinish net }
  TestPlusArgs s        -> dfltNV { decl = Just $ declWire 1 nId
                                  , inst = Just $ instTestPlusArgs net s }
  Input w s             -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInput net s }
  Output w s            -> dfltNV { inst = Just $ instOutput net s }
  RegFileMake f aw dw i -> dfltNV { decl = Just $ declRegFile f aw dw i }
  RegFileRead w id      -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instRegFileRead id net }
  RegFileWrite _ _ id   -> dfltNV { alws = Just $ alwsRegFileWrite id net }
  Custom p is os ps     -> dfltNV {
                              decl = Just $ sep [ declWire w (netInstId net, n)
                                                | ((o, w), n) <- zip os [0..] ]
                            , inst = Just $ instCustom net p is os ps }
  where nId = (netInstId net, 0)
        dfltNV = NetVerilog { decl = Nothing
                            , inst = Nothing
                            , alws = Nothing }
