{-|
Module      : Blarney.Verilog
Description : Verilog generation
Copyright   : (c) Matthew Naylor, 2019
License     : MIT
Maintainer  : mattfn@gmail.com
Stability   : experimental

Convert Blarney functions to Verilog modules.
-}
module Blarney.Verilog
  ( writeVerilogModule  -- Generate Verilog module
  , writeVerilogTop     -- Generate Verilog top-level module
  ) where

-- Standard imports
import Prelude
import Data.List
import System.IO
import Data.Maybe
import Control.Monad
import System.Process

-- Blarney imports
import Blarney.BV
import Blarney.Util
import Blarney.Module
import Blarney.Interface
import Blarney.IfThenElse

-- |Convert given Blarney function to a Verilog module
writeVerilogModule :: Modular a
                   => a          -- ^ Blarney function
                   -> String     -- ^ Module name
                   -> String     -- ^ Output directory
                   -> IO () 
writeVerilogModule top mod dir =
    do system ("mkdir -p " ++ dir)
       nl <- netlist (makeModule top)
       writeVerilog fileName mod nl
  where
    fileName = dir ++ "/" ++ mod ++ ".v"

-- |Convert given Blarney function to a top-level Verilog module
writeVerilogTop :: Module ()  -- ^ Blarney module
                -> String     -- ^ Top-level module name
                -> String     -- ^ Output directory
                -> IO ()
writeVerilogTop top mod dir =
    do nl <- netlist top
       system ("mkdir -p " ++ dir)
       writeVerilog (dir ++ "/" ++ mod ++ ".v") mod nl
       writeFile (dir ++ "/" ++ mod ++ ".cpp") simCode
       writeFile (dir ++ "/" ++ mod ++ ".mk") makefileIncCode
       writeFile (dir ++ "/Makefile") makefileCode
  where
    fileName = dir ++ "/" ++ mod ++ ".v"

    simCode =
      unlines [
        "// Generated by Blarney"
      , "#include <verilated.h>"
      , "#include \"V" ++ mod ++ ".h\""
      , "V" ++ mod ++ " *top;"
      , "vluint64_t main_time = 0;"
      , "// Called by $time in Verilog"
      , "double sc_time_stamp () {"
      , "  return main_time;"
      , "}"
      , "int main(int argc, char** argv) {"
      , "  Verilated::commandArgs(argc, argv);"
      , "  top = new V" ++ mod ++ ";"
      , "  while (!Verilated::gotFinish()) {"
      , "    top->clock = 0; top->eval();"
      , "    top->clock = 1; top->eval();"
      , "    main_time++;"
      , "  }"
      , "  top->final(); delete top; return 0;"
      , "}"
      ]

    makefileIncCode =
      unlines [
        "all: " ++ mod
      , mod ++ ": *.v *.cpp"
      , "\tverilator -cc " ++ mod ++ ".v " ++ "-exe "
                           ++ mod ++ ".cpp " ++ "-o " ++ mod
                           ++ " -Wno-UNSIGNED "
                           ++ " -y $(BLARNEY_ROOT)/Verilog "
      , "\tmake -C obj_dir -j -f V" ++ mod ++ ".mk " ++ mod
      , "\tcp obj_dir/" ++ mod ++ " ."
      , "\trm -rf obj_dir"
      , ".PHONY: clean clean-" ++ mod
      , "clean: clean-" ++ mod
      , "clean-" ++ mod ++ ":"
      , "\trm -f " ++ mod
      ]

    makefileCode = "include *.mk"

generateVerilog :: Modular a => a -> String -> IO ()
generateVerilog top mod =
  netlist (makeModule top) >>= writeVerilog fileName mod
  where fileName = mod ++ ".v"

writeVerilog :: String -> String -> [Net] -> IO ()
writeVerilog fileName modName netlist = do
  h <- openFile fileName WriteMode
  hWriteVerilog h modName netlist
  hClose h

hWriteVerilog :: Handle -> String -> [Net] -> IO ()
hWriteVerilog h modName netlist = do
    emit ("module " ++ modName ++ "(\n")
    emit "  input wire clock\n"
    emitInputOutputs (map netPrim netlist)
    emit ");\n"
    mapM_ emitDecl netlist
    mapM_ emitInst netlist
    emit "always @(posedge clock) begin\n"
    mapM_ emitAlways netlist
    emit "end\n"
    emit "endmodule\n"
  where
    emit = hPutStr h

    emitWire (instId, outNum) = do
      emit "v"
      emit (show instId)
      emit "_"
      emit (show outNum)

    emitInput = emitWire

    emitDeclHelper width wire = do
      emit "["
      emit (show (width-1))
      emit ":0] "
      emitWire wire
      emit ";\n"

    emitDeclInitHelper width wire init = do
      emit "["
      emit (show (width-1))
      emit ":0] "
      emitWire wire
      emit " = "
      emit (show width)
      emit "'d"
      emit (show init)
      emit ";\n"

    emitDeclInitBitsHelper width wire b = do
      emit "["
      emit (show (width-1))
      emit ":0] "
      emitWire wire
      emit " = "
      emit (show width)
      emit "'d"
      let chr One = '1'
          chr Zero = '0'
          chr DontCare = 'x'
      emit (replicate width (chr b))
      emit ";\n"

    emitWireDecl width wire = do
      emit "wire "
      emitDeclHelper width wire

    emitWireInitDecl width wire init = do
      emit "wire "
      emitDeclInitHelper width wire init

    emitWireInitBitsDecl width wire b = do
      emit "wire "
      emitDeclInitBitsHelper width wire b

    emitRegDecl width wire = do
      emit "reg "
      emitDeclHelper width wire

    emitRegInitDecl width wire init = do
      emit "reg "
      emitDeclInitHelper width wire init

    emitRAMDecl initFile numPorts aw dw id = do
      forM_ [0..numPorts-1] $ \p ->
        emitWireDecl dw (id, p)

    emitRegFileDecl initFile aw dw id = do
      emit "reg ["
      emit (show (dw-1))
      emit ":0] "
      emit ("rf" ++ show id)
      emit "[(2**"
      emit (show aw)
      emit ")-1:0];\n"
      case initFile of
        "" -> return ()
        other -> do
          emit "generate initial $readmemh("
          emit (show initFile)
          emit ", "
          emit ("rf" ++ show id)
          emit "); endgenerate\n"

    emitDecl net =
      let wire = (netInstId net, 0) in
        case netPrim net of
          Const w i             -> emitWireInitDecl w wire i
          ConstBits w b         -> emitWireInitBitsDecl w wire b
          Add w                 -> emitWireDecl w wire
          Sub w                 -> emitWireDecl w wire
          Mul w                 -> emitWireDecl w wire
          Div w                 -> emitWireDecl w wire
          Mod w                 -> emitWireDecl w wire
          Not w                 -> emitWireDecl w wire
          And w                 -> emitWireDecl w wire
          Or  w                 -> emitWireDecl w wire
          Xor w                 -> emitWireDecl w wire
          ShiftLeft w           -> emitWireDecl w wire
          ShiftRight w          -> emitWireDecl w wire
          Equal w               -> emitWireDecl 1 wire
          NotEqual w            -> emitWireDecl 1 wire
          LessThan w            -> emitWireDecl 1 wire
          LessThanEq w          -> emitWireDecl 1 wire
          Register i w          -> emitRegInitDecl w wire i
          RegisterEn i w        -> emitRegInitDecl w wire i
          BRAM i aw dw          -> emitRAMDecl i 1 aw dw (netInstId net)
          TrueDualBRAM i aw dw  -> emitRAMDecl i 2 aw dw (netInstId net)
          ReplicateBit w        -> emitWireDecl w wire
          ZeroExtend wi wo      -> emitWireDecl wo wire
          SignExtend wi wo      -> emitWireDecl wo wire
          SelectBits w hi lo    -> emitWireDecl (1+hi-lo) wire
          Concat aw bw          -> emitWireDecl (aw+bw) wire
          Mux w                 -> emitWireDecl w wire
          CountOnes w           -> emitWireDecl w wire
          Identity w            -> emitWireDecl w wire
          Display args          -> return ()
          Finish                -> return ()
          Input w s             -> emitWireDecl w wire
          Output w s            -> return ()
          RegFileMake f aw dw i -> emitRegFileDecl f aw dw i
          RegFileRead w id      -> emitWireDecl w wire
          RegFileWrite _ _ _    -> return ()
          Custom p is os ps     -> 
            sequence_ [ emitWireDecl w (netInstId net, n)
                      | ((o, w), n) <- zip os [0..] ]

    emitInputOutputs nets = mapM_ emitInputOutput (ins ++ outs)
      where
        ins = [Input w s | (w, s) <- nub [(w, s) | Input w s <- nets]]
        outs = [Output w s | Output w s <- nets]

    emitInputOutput prim =
      case prim of
        Input w s ->
          emit (", input wire [" ++ show (w-1) ++ ":0] " ++ s ++ "\n")
        Output w s -> 
          emit (", output wire [" ++ show (w-1) ++ ":0] " ++ s ++ "\n")
        other -> return ()

    emitAssignConst :: Width -> Integer -> Net -> IO ()
    emitAssignConst w i net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emit (show w)
      emit "'d" >>  emit (show i) >> emit ";\n"

    emitPrefixOpInst op net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = " >> emit op >> emit "("
      emitInput (netInputs net !! 0)
      emit ");\n"

    emitInfixOpInst op net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emitInput (netInputs net !! 0)
      emit " " >> emit op >> emit " "
      emitInput (netInputs net !! 1)
      emit ";\n"

    emitShiftInst w op net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emitInput (netInputs net !! 0)
      emit " " >> emit op >> emit " "
      let amount = netInputs net !! 1
      let hi = log2ceil w
      emitInput (netInputs net !! 1)
      emit ("[" ++ show hi ++ ":0]")
      emit ";\n"

    emitReplicateInst w net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = {"
      emit (show w)
      emit "{"
      emitInput (netInputs net !! 0)
      emit "}};\n"

    emitMuxInst net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emitInput (netInputs net !! 0)
      emit " ? "
      emitInput (netInputs net !! 1)
      emit " : "
      emitInput (netInputs net !! 2)
      emit ";\n"

    emitConcatInst net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = {"
      emitInput (netInputs net !! 0)
      emit ","
      emitInput (netInputs net !! 1)
      emit "};\n"

    emitSelectBitsInst net hi lo = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emitInput (netInputs net !! 0)
      emit "["
      emit (show hi)
      emit ":"
      emit (show lo)
      emit "];\n"

    emitZeroExtendInst net wi wo = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emit "{{"
      emit (show (wo-wi))
      emit "{1'b0}},"
      emitInput (netInputs net !! 0)
      emit "};\n"

    emitSignExtendInst net wi wo = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emit "{"
      emit (show (wo-wi))
      emit "{"
      emitInput (netInputs net !! 0)
      emit "["
      emit (show (wi-1))
      emit "],"
      emitInput (netInputs net !! 0)
      emit "};\n"

    emitCustomInst net name ins outs params = do
      emit name >> emit " "
      let numParams = length params
      if numParams == 0
        then return ()
        else do
          emit "#(\n"
          sequence_
               [ do emit "  ." >> emit key
                    emit "(" >> emit val >> emit ")"
                    if i < numParams then emit ",\n" else return ()
               | (key :-> val, i) <- zip params [1..] ]
          emit "\n)\n"
      emit (name ++ "_" ++ show (netInstId net))
      let args = zip ins (netInputs net) ++
                   [ (o, (netInstId net, n))
                   | (o, n) <- zip (map fst outs) [0..] ]
      let numArgs = length args
      emit "(\n"
      emit "  .clock(clock),\n"
      if numArgs == 0
        then return ()
        else do
          sequence_
             [ do emit "  ." >> emit name
                  emit "(" >> emitWire wire >> emit ")"
                  if i < numArgs then emit ",\n" else return ()
             | ((name, wire), i) <- zip args [1..] ]
      emit "\n);\n"

    emitOutputInst net s = do
      emit ("assign " ++ s ++ " = ")
      emitInput (netInputs net !! 0)
      emit ";\n"

    emitInputInst net s = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emit s
      emit ";\n"

    emitRAMInst net i aw dw = do
      let initFile = fromMaybe "UNUSED" i
      emit "BlockRAM#(\n"
      emit (".INIT_FILE(" ++ show initFile ++ "),\n")
      emit (".ADDR_WIDTH(" ++ show aw ++ "),\n")
      emit (".DATA_WIDTH(" ++ show dw ++ "))\n")
      emit ("ram" ++ show (netInstId net) ++ " (\n")
      emit ".CLK(clock),\n"
      emit ".DI(" >> emitInput (netInputs net !! 1) >> emit "),\n"
      emit ".ADDR(" >> emitInput (netInputs net !! 0) >> emit "),\n"
      emit ".WE(" >> emitInput (netInputs net !! 2) >> emit "),\n"
      emit ".DO(" >> emitWire (netInstId net, 0) >> emit "));\n"

    emitTrueDualRAMInst net i aw dw = do
      let initFile = fromMaybe "UNUSED" i
      emit "BlockRAMTrueDual#(\n"
      emit (".INIT_FILE(" ++ show initFile ++ "),\n")
      emit (".ADDR_WIDTH(" ++ show aw ++ "),\n")
      emit (".DATA_WIDTH(" ++ show dw ++ "))\n")
      emit ("ram" ++ show (netInstId net) ++ " (\n")
      emit ".CLK(clock),\n"
      emit ".DI_A(" >> emitInput (netInputs net !! 1) >> emit "),\n"
      emit ".ADDR_A(" >> emitInput (netInputs net !! 0) >> emit "),\n"
      emit ".WE_A(" >> emitInput (netInputs net !! 2) >> emit "),\n"
      emit ".DO_A(" >> emitWire (netInstId net, 0) >> emit "),\n"
      emit ".DI_B(" >> emitInput (netInputs net !! 4) >> emit "),\n"
      emit ".ADDR_B(" >> emitInput (netInputs net !! 3) >> emit "),\n"
      emit ".WE_B(" >> emitInput (netInputs net !! 5) >> emit "),\n"
      emit ".DO_B(" >> emitWire (netInstId net, 1) >> emit "));\n"

    emitRegFileReadInst id net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = rf" >> emit (show id) >> emit "["
      emitInput (netInputs net !! 0)
      emit "];\n"

    emitInst net =
      case netPrim net of
        Const w i           -> return ()
        ConstBits w b       -> return ()
        Add w               -> emitInfixOpInst "+" net
        Sub w               -> emitInfixOpInst "-" net
        Mul w               -> emitInfixOpInst "*" net
        Div w               -> emitInfixOpInst "/" net
        Mod w               -> emitInfixOpInst "%" net
        Not w               -> emitPrefixOpInst "~" net
        And w               -> emitInfixOpInst "&" net
        Or  w               -> emitInfixOpInst "|" net
        Xor w               -> emitInfixOpInst "^" net
        ShiftLeft w         -> emitShiftInst w "<<" net
        ShiftRight w        -> emitShiftInst w ">>" net
        Equal w             -> emitInfixOpInst "==" net
        NotEqual w          -> emitInfixOpInst "!=" net
        LessThan w          -> emitInfixOpInst "<" net
        LessThanEq w        -> emitInfixOpInst "<=" net
        Register i w        -> return ()
        RegisterEn i w      -> return ()
        BRAM i aw dw        -> emitRAMInst net i aw dw
        TrueDualBRAM i aw dw -> emitTrueDualRAMInst net i aw dw
        ReplicateBit w      -> emitReplicateInst w net
        ZeroExtend wi wo    -> emitZeroExtendInst net wi wo
        SignExtend wi wo    -> emitSignExtendInst net wi wo
        SelectBits w hi lo  -> emitSelectBitsInst net hi lo
        Concat aw bw        -> emitConcatInst net
        Mux w               -> emitMuxInst net
        CountOnes w         -> emitPrefixOpInst "$countones" net
        Identity w          -> emitPrefixOpInst "" net
        Display args        -> return ()
        Finish              -> return ()
        Input w s           -> emitInputInst net s
        Output w s          -> emitOutputInst net s
        RegFileMake _ _ _ _ -> return ()
        RegFileRead w id    -> emitRegFileReadInst id net
        RegFileWrite _ _ _  -> return ()
        Custom p is os ps   -> emitCustomInst net p is os ps
 
    emitAlways net =
      case netPrim net of
        Register init w -> do
          emitWire (netInstId net, 0)
          emit " <= "
          emitInput (netInputs net !! 0)
          emit ";\n"
        RegisterEn init w -> do
          emit "if ("
          emitInput (netInputs net !! 0)
          emit " == 1) "
          emitWire (netInstId net, 0)
          emit " <= "
          emitInput (netInputs net !! 1)
          emit ";\n"
        Display args -> do
          emit "if ("
          emitInput (netInputs net !! 0)
          emit " == 1) $display(\""
          emitDisplayFormat args
          emit ","
          emitDisplayArgs args (tail (netInputs net))
          emit ");\n"
        Finish -> do
          emit "if ("
          emitInput (netInputs net !! 0)
          emit " == 1) $finish;\n"
        RegFileWrite aw dw id -> do
          emit "if ("
          emitInput (netInputs net !! 0)
          emit " == 1) "
          emit "rf"
          emit (show id)
          emit "["
          emitInput (netInputs net !! 1)
          emit "] <= "
          emitInput (netInputs net !! 2)
          emit ";\n"
        other -> return ()

    emitDisplayFormat [] = emit "\""
    emitDisplayFormat (DisplayArgString s : args) = do
      emit "%s"
      emitDisplayFormat args
    emitDisplayFormat (DisplayArgBit w : args) = do
      emit "0x%x"
      emitDisplayFormat args

    emitDisplayArgs [] _ = return ()
    emitDisplayArgs (DisplayArgString s : args) wires = do
      emit ("\"" ++ s ++ "\"")
      if null args then return () else emit ","
      emitDisplayArgs args wires
    emitDisplayArgs (DisplayArgBit w : args) (wire:wires) = do
      emitInput wire
      if null args then return () else emit ","
      emitDisplayArgs args wires
