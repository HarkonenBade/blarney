-- Emit netlist in Verilog format

module Blarney.EmitVerilog
  ( writeVerilog
  , generateVerilog
  , emitVerilogModule
  , emitVerilogTop
  ) where

import Prelude
import Blarney.Unbit
import Blarney.IfThenElse
import Blarney.RTL
import Blarney.Interface
import Blarney.Util
import System.IO
import Data.Maybe
import Data.List
import Control.Monad
import System.IO
import System.Process

emitVerilogModule :: Module a => a -> String -> String -> IO ()
emitVerilogModule top mod dir =
    do system ("mkdir -p " ++ dir)
       nl <- netlist (makeModule top)
       writeVerilog fileName mod nl
  where
    fileName = dir ++ "/" ++ mod ++ ".v"

emitVerilogTop :: RTL () -> String -> String -> IO ()
emitVerilogTop top mod dir =
    do nl <- netlist top
       system ("mkdir -p " ++ dir)
       writeVerilog (dir ++ "/" ++ mod ++ ".v") mod nl
       writeFile (dir ++ "/" ++ mod ++ ".cpp") simCode
       writeFile (dir ++ "/Makefile") makefileCode
  where
    fileName = dir ++ "/" ++ mod ++ ".v"

    simCode =
      unlines [
        "// Generated by Blarney"
      , "#include <verilated.h>"
      , "#include \"V" ++ mod ++ ".h\""
      , "V" ++ mod ++ " *top;"
      , "vluint64_t main_time = 0;"
      , "// Called by $time in Verilog"
      , "double sc_time_stamp () {"
      , "  return main_time;"
      , "}"
      , "int main(int argc, char** argv) {"
      , "  Verilated::commandArgs(argc, argv);"
      , "  top = new Vtop;"
      , "  while (!Verilated::gotFinish()) {"
      , "    top->clock = 0; top->eval();"
      , "    top->clock = 1; top->eval();"
      , "    main_time++;"
      , "  }"
      , "  top->final(); delete top; return 0;"
      , "}"
      ]

    makefileCode =
      unlines [
        mod ++ ": *.v *.cpp"
      , "\tverilator -cc " ++ mod ++ ".v " ++ "-exe "
                           ++ mod ++ ".cpp " ++ "-o " ++ mod
                           ++ " -y $(BLARNEY_ROOT)/Verilog"
      , "\tmake -C obj_dir -j -f V" ++ mod ++ ".mk " ++ mod
      , "\tcp obj_dir/" ++ mod ++ " ."
      , "\trm -rf obj_dir"
      , ".PHONY: clean"
      , "clean:"
      , "\trm " ++ mod
      ]

generateVerilog :: Module a => a -> String -> IO ()
generateVerilog top mod =
  netlist (makeModule top) >>= writeVerilog fileName mod
  where fileName = mod ++ ".v"

writeVerilog :: String -> String -> [Net] -> IO ()
writeVerilog fileName modName netlist = do
  h <- openFile fileName WriteMode
  hWriteVerilog h modName netlist
  hClose h

hWriteVerilog :: Handle -> String -> [Net] -> IO ()
hWriteVerilog h modName netlist = do
    emit ("module " ++ modName ++ "(\n")
    emit "  input wire clock\n"
    emitInputOutputs (map netPrim netlist)
    emit ");\n"
    mapM_ emitDecl netlist
    mapM_ emitInst netlist
    emit "always @(posedge clock) begin\n"
    mapM_ emitAlways netlist
    emit "end\n"
    emit "endmodule\n"
  where
    emit = hPutStr h

    emitWire (instId, outNum) = do
      emit "v"
      emit (show instId)
      emit "_"
      emit (show outNum)

    emitInput = emitWire

    emitDeclHelper width wire = do
      emit "["
      emit (show (width-1))
      emit ":0] "
      emitWire wire
      emit ";\n"

    emitDeclInitHelper width wire init = do
      emit "["
      emit (show (width-1))
      emit ":0] "
      emitWire wire
      emit " = "
      emit (show width)
      emit "'d"
      emit (show init)
      emit ";\n"

    emitWireDecl width wire = do
      emit "wire "
      emitDeclHelper width wire

    emitWireInitDecl width wire init = do
      emit "wire "
      emitDeclInitHelper width wire init

    emitRegDecl width wire = do
      emit "reg "
      emitDeclHelper width wire

    emitRegInitDecl width wire init = do
      emit "reg "
      emitDeclInitHelper width wire init

    emitRAMDecl initFile numPorts aw dw id = do
      forM_ [0..numPorts-1] $ \p ->
        emitWireDecl dw (id, p)

    emitDecl net =
      let wire = (netInstId net, 0) in
        case netPrim net of
          Const w i           -> emitWireInitDecl w wire i
          Add w               -> emitWireDecl w wire
          Sub w               -> emitWireDecl w wire
          Mul w               -> emitWireDecl w wire
          Div w               -> emitWireDecl w wire
          Mod w               -> emitWireDecl w wire
          Not w               -> emitWireDecl w wire
          And w               -> emitWireDecl w wire
          Or  w               -> emitWireDecl w wire
          Xor w               -> emitWireDecl w wire
          ShiftLeft w         -> emitWireDecl w wire
          ShiftRight w        -> emitWireDecl w wire
          Equal w             -> emitWireDecl 1 wire
          NotEqual w          -> emitWireDecl 1 wire
          LessThan w          -> emitWireDecl 1 wire
          LessThanEq w        -> emitWireDecl 1 wire
          Register i w        -> emitRegInitDecl w wire i
          RegisterEn i w      -> emitRegInitDecl w wire i
          RAM i aw dw         -> emitRAMDecl i 1 aw dw (netInstId net)
          TrueDualRAM i aw dw -> emitRAMDecl i 2 aw dw (netInstId net)
          ReplicateBit w      -> emitWireDecl w wire
          ZeroExtend wi wo    -> emitWireDecl wo wire
          SignExtend wi wo    -> emitWireDecl wo wire
          SelectBits w hi lo  -> emitWireDecl (1+hi-lo) wire
          Concat aw bw        -> emitWireDecl (aw+bw) wire
          Mux w               -> emitWireDecl w wire
          CountOnes w         -> emitWireDecl w wire
          Identity w          -> emitWireDecl w wire
          Display args        -> return ()
          Finish              -> return ()
          Input w s           -> emitWireDecl w wire
          Output w s          -> return ()
          Custom p is os ps   -> 
            sequence_ [ emitWireDecl w (netInstId net, n)
                      | ((o, w), n) <- zip os [0..] ]

    emitInputOutputs nets = mapM_ emitInputOutput (ins ++ outs)
      where
        ins = [Input w s | (w, s) <- nub [(w, s) | Input w s <- nets]]
        outs = [Output w s | Output w s <- nets]

    emitInputOutput prim =
      case prim of
        Input w s ->
          emit (", input wire [" ++ show (w-1) ++ ":0] " ++ s ++ "\n")
        Output w s -> 
          emit (", output wire [" ++ show (w-1) ++ ":0] " ++ s ++ "\n")
        other -> return ()

    emitAssignConst :: Width -> Integer -> Net -> IO ()
    emitAssignConst w i net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emit (show w)
      emit "'d" >>  emit (show i) >> emit ";\n"

    emitPrefixOpInst op net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = " >> emit op >> emit "("
      emitInput (netInputs net !! 0)
      emit ");\n"

    emitInfixOpInst op net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emitInput (netInputs net !! 0)
      emit " " >> emit op >> emit " "
      emitInput (netInputs net !! 1)
      emit ";\n"

    emitShiftInst w op net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emitInput (netInputs net !! 0)
      emit " " >> emit op >> emit " "
      let amount = netInputs net !! 1
      let hi = log2ceil w
      emitInput (netInputs net !! 1)
      emit ("[" ++ show hi ++ ":0]")
      emit ";\n"

    emitReplicateInst w net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = {"
      emit (show w)
      emit "{"
      emitInput (netInputs net !! 0)
      emit "}};\n"

    emitMuxInst net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emitInput (netInputs net !! 0)
      emit " ? "
      emitInput (netInputs net !! 1)
      emit " : "
      emitInput (netInputs net !! 2)
      emit ";\n"

    emitConcatInst net = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = {"
      emitInput (netInputs net !! 0)
      emit ","
      emitInput (netInputs net !! 1)
      emit "};\n"

    emitSelectBitsInst net hi lo = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emitInput (netInputs net !! 0)
      emit "["
      emit (show hi)
      emit ":"
      emit (show lo)
      emit "];\n"

    emitZeroExtendInst net wi wo = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emit "{{"
      emit (show (wo-wi))
      emit "{1'b0}},"
      emitInput (netInputs net !! 0)
      emit "};\n"

    emitSignExtendInst net wi wo = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emit "{"
      emit (show (wo-wi))
      emit "{"
      emitInput (netInputs net !! 0)
      emit "["
      emit (show (wi-1))
      emit "],"
      emitInput (netInputs net !! 0)
      emit "};\n"

    emitCustomInst net name ins outs params = do
      emit name >> emit " "
      let numParams = length params
      if numParams == 0
        then return ()
        else do
          emit "#("
          sequence_
               [ do emit "." >> emit key
                    emit "(" >> emit val >> emit ")"
                    if i < numParams then emit ",\n" else return ()
               | (key :-> val, i) <- zip params [1..] ]
      emit (name ++ "_" ++ show (netInstId net))
      let args = zip ins (netInputs net) ++
                   [ (o, (netInstId net, n))
                   | (o, n) <- zip (map fst outs) [0..] ]
      let numArgs = length args
      emit "(\n"
      emit ".clock(clock),\n"
      if numArgs == 0
        then return ()
        else do
          sequence_
             [ do emit "." >> emit name
                  emit "(" >> emitWire wire >> emit ")"
                  if i < numArgs then emit ",\n" else return ()
             | ((name, wire), i) <- zip args [1..] ]
      emit ");\n"

    emitOutputInst net s = do
      emit ("assign " ++ s ++ " = ")
      emitInput (netInputs net !! 0)
      emit ";\n"

    emitInputInst net s = do
      emit "assign "
      emitWire (netInstId net, 0)
      emit " = "
      emit s
      emit ";\n"

    emitRAMInst net i aw dw = do
      let initFile = fromMaybe "UNUSED" i
      emit "BlockRAM#(\n"
      emit (".INIT_FILE(" ++ show initFile ++ "),\n")
      emit (".ADDR_WIDTH(" ++ show aw ++ "),\n")
      emit (".DATA_WIDTH(" ++ show dw ++ "))\n")
      emit ("ram" ++ show (netInstId net) ++ " (\n")
      emit ".CLK(clock),\n"
      emit ".DI(" >> emitInput (netInputs net !! 1) >> emit "),\n"
      emit ".ADDR(" >> emitInput (netInputs net !! 0) >> emit "),\n"
      emit ".WE(" >> emitInput (netInputs net !! 2) >> emit "),\n"
      emit ".DO(" >> emitWire (netInstId net, 0) >> emit "));\n"

    emitTrueDualRAMInst net i aw dw = do
      let initFile = fromMaybe "UNUSED" i
      emit "BlockRAMTrueDual#(\n"
      emit (".INIT_FILE(" ++ show initFile ++ "),\n")
      emit (".ADDR_WIDTH(" ++ show aw ++ "),\n")
      emit (".DATA_WIDTH(" ++ show dw ++ "))\n")
      emit ("ram" ++ show (netInstId net) ++ " (\n")
      emit ".CLK(clock),\n"
      emit ".DI_A(" >> emitInput (netInputs net !! 1) >> emit "),\n"
      emit ".ADDR_A(" >> emitInput (netInputs net !! 0) >> emit "),\n"
      emit ".WE_A(" >> emitInput (netInputs net !! 2) >> emit "),\n"
      emit ".DO_A(" >> emitWire (netInstId net, 0) >> emit "),\n"
      emit ".DI_B(" >> emitInput (netInputs net !! 4) >> emit "),\n"
      emit ".ADDR_B(" >> emitInput (netInputs net !! 3) >> emit "),\n"
      emit ".WE_B(" >> emitInput (netInputs net !! 5) >> emit "),\n"
      emit ".DO_B(" >> emitWire (netInstId net, 1) >> emit "));\n"

    emitInst net =
      case netPrim net of
        Const w i           -> return ()
        Add w               -> emitInfixOpInst "+" net
        Sub w               -> emitInfixOpInst "-" net
        Mul w               -> emitInfixOpInst "*" net
        Div w               -> emitInfixOpInst "/" net
        Mod w               -> emitInfixOpInst "%" net
        Not w               -> emitPrefixOpInst "~" net
        And w               -> emitInfixOpInst "&" net
        Or  w               -> emitInfixOpInst "|" net
        Xor w               -> emitInfixOpInst "^" net
        ShiftLeft w         -> emitShiftInst w "<<" net
        ShiftRight w        -> emitShiftInst w ">>" net
        Equal w             -> emitInfixOpInst "==" net
        NotEqual w          -> emitInfixOpInst "!=" net
        LessThan w          -> emitInfixOpInst "<" net
        LessThanEq w        -> emitInfixOpInst "<=" net
        Register i w        -> return ()
        RegisterEn i w      -> return ()
        RAM i aw dw         -> emitRAMInst net i aw dw
        TrueDualRAM i aw dw -> emitTrueDualRAMInst net i aw dw
        ReplicateBit w      -> emitReplicateInst w net
        ZeroExtend wi wo    -> emitZeroExtendInst net wi wo
        SignExtend wi wo    -> emitSignExtendInst net wi wo
        SelectBits w hi lo  -> emitSelectBitsInst net hi lo
        Concat aw bw        -> emitConcatInst net
        Mux w               -> emitMuxInst net
        CountOnes w         -> emitPrefixOpInst "$countones" net
        Identity w          -> emitPrefixOpInst "" net
        Display args        -> return ()
        Finish              -> return ()
        Input w s           -> emitInputInst net s
        Output w s          -> emitOutputInst net s
        Custom p is os ps   -> emitCustomInst net p is os ps
 
    emitAlways net =
      case netPrim net of
        Register init w -> do
          emitWire (netInstId net, 0)
          emit " <= "
          emitInput (netInputs net !! 0)
          emit ";\n"
        RegisterEn init w -> do
          emit "if ("
          emitInput (netInputs net !! 0)
          emit " == 1) "
          emitWire (netInstId net, 0)
          emit " <= "
          emitInput (netInputs net !! 1)
          emit ";\n"
        Display args -> do
          emit "if ("
          emitInput (netInputs net !! 0)
          emit " == 1) $display(\""
          emitDisplayFormat args
          emit ","
          emitDisplayArgs args (tail (netInputs net))
          emit ");\n"
        Finish -> do
          emit "if ("
          emitInput (netInputs net !! 0)
          emit " == 1) $finish;\n"
        other -> return ()

    emitDisplayFormat [] = emit "\""
    emitDisplayFormat (DisplayArgString s : args) = do
      emit "%s"
      emitDisplayFormat args
    emitDisplayFormat (DisplayArgBit w : args) = do
      emit "0x%x"
      emitDisplayFormat args

    emitDisplayArgs [] _ = return ()
    emitDisplayArgs (DisplayArgString s : args) wires = do
      emit ("\"" ++ s ++ "\"")
      if null args then return () else emit ","
      emitDisplayArgs args wires
    emitDisplayArgs (DisplayArgBit w : args) (wire:wires) = do
      emitInput wire
      if null args then return () else emit ","
      emitDisplayArgs args wires
